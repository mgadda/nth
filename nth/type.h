// // Types for representing types during type inference (not ASTNodes)

#include <set>
#include "ast.h"

namespace nth {

class Symbol;

typedef std::set<Symbol*> VariableSet;
typedef std::set<Symbol*> MethodSet;

// Represents a type in the semantic sense, as opposed to
// TypeDef/Ref which represent AST nodes generated by the
// parser
class Type {
 public:
  Type(Identifier *name, VariableSet variables, MethodSet methods, Type *parent);

  // TODO: define operators that allow comparison of parent/child types
  virtual bool operator==(Type &rhs);
  virtual bool operator==(Type *rhs);
  bool operator!=(Type &rhs);
  bool operator!=(Type *rhs);

  static Type *computeLUB(std::set<Type*> types);
  static Type *objectType();

  Identifier *getName() { return name; }
  Type *getParent() { return parent; }
  VariableSet &getVariables() { return variables; }
  MethodSet &getMethods() { return methods; }

  // recursively find method that matches signature required by arg types
  Type *findMethodReturnTypeForArgs(std::string methodSymbolName, std::list<Type*> args);

  virtual ~Type() {}

 protected:
  bool concrete=true; // TODO: use this
  Identifier *name;
  Type *parent;
  VariableSet variables;
  MethodSet methods;

  static Type *_objectType;
};

// SimpleType and TemplatedType represent actual defined types
class SimpleType : public Type {
 public:
  SimpleType(Identifier *name, VariableSet variables, MethodSet methods, Type* parent)
   : Type(name, variables, methods, parent) {}

  ~SimpleType() {}
};

// Example: List in List[A], Function1[Int, Int]
class TemplatedType : public Type {
 public:
  TemplatedType(Identifier *name, VariableSet variables, MethodSet methods, Type *parent, TypeList subtypes)
   : Type(name, variables, methods, parent), _subtypes(subtypes) {}

  // List[A] -> List[Int]
  TemplatedType *specialize(TypeList subtypes);
  TypeList getSubtypes() { return _subtypes; }
  
  ~TemplatedType() {}
 protected:
  VariableSet variables;
  MethodSet methods;
  TypeList _subtypes; // TODO: describe subtype relationships more fully
  bool specialized = false;
};

class FunctionType : public TemplatedType {
 public:
  // TODO: functions as objects have methods (namely, apply())
  FunctionType(TypeList argTypes, Type *returnType);
  TypeList concat_ctr_args(TypeList argList, Type *returnType);

  TypeList getArgTypes();
  Type *getReturnType();
};

}
