// // Types for representing types during type inference (not ASTNodes)

#include <set>
#include "ast.h"

namespace nth {

class Symbol;

typedef std::set<Symbol*> VariableSet;
typedef std::set<Symbol*> MethodSet;

// Represents a type in the semantic sense, as opposed to
// TypeDef/Ref which represent AST nodes generated by the
// parser
// Type is abstract and cannot be instnatiated directly.
class Type {
 public:
  // TODO: define operators that allow comparison of parent/child types
  virtual bool operator==(Type *rhs);
  bool operator!=(Type *rhs);

  virtual Identifier *getName() { return name; }
  virtual TypeList getParents()=0;
  virtual VariableSet &getVariables()=0;
  virtual MethodSet &getMethods()=0;
  virtual bool isSpecialized()=0;

  static Type *computeLUB(std::set<Type*> types);
  static Type *objectType();

  // recursively find method that matches signature required by arg types
  Type *findMethodReturnTypeForArgs(std::string methodSymbolName, std::list<Type*> args);

  virtual ~Type() {}

 protected:
  Type(Identifier *name) : name(name) {}

  static Type *_objectType;
  Identifier *name;
};

class ConcreteType : public Type {
 public:
  TypeList getParents() { return parents; }
  VariableSet &getVariables() { return variables; }
  MethodSet &getMethods() { return methods; }

 protected:
  ConcreteType(Identifier *name, VariableSet variables, MethodSet methods, TypeList parents)
  : Type(name), variables(getVariables()), methods(getMethods()), parents(parents) {}

  VariableSet variables;
  MethodSet methods;
  TypeList parents;
};

// SimpleType and TemplatedType represent actual defined types
class SimpleType : public ConcreteType {
 public:
  SimpleType(Identifier *name, VariableSet variables, MethodSet methods, TypeList parents)
   : ConcreteType(name, variables, methods, parents) {}

  bool isSpecialized() { return true; }

  ~SimpleType() {}
};

// Example: List in List[A], Function1 in Function1[T1, R]
class TemplatedType : public ConcreteType {
 public:
  TemplatedType(Identifier*     name,
                VariableSet     variables,
                MethodSet       methods,
                TypeList        parents,
                GenericTypeList genericTypes);

  // List[A] -> List[Int]
  // Note: type list must have same length as list returned by getGenericTypes
  // types do not need to be concrete
  TemplatedType *specialize(TypeList types);
  // true if all generic types are specialized
  bool isSpecialized(); // TODO: implement move semantics?

  GenericTypeList getGenericTypes() { return _genericTypes; }

  ~TemplatedType() {}
 protected:
  VariableSet variables;
  MethodSet methods;
  GenericTypeList _genericTypes; // TODO: support generic type constraints
};

/*
A in List[A]. GenericType is container for another type, concrete or generic.
Thus, delegateType does not have to be concrete. Consider:

trait Foo[A]
class Bar[B] extends Foo[B]

new Bar[Int] // i.e. Bar_ctor(): Bar[Int]

The type of Bar_ctor ultimately becomes Function0[Bar[Int]]
And thus, whenever Foo refers to type A, it's really forwarding to a type
called B when used in the context of Bar. And whenever Bar refers to type B,
it's really forwarding to a type Int, when used in the context of new Bar[Int].
 */
class GenericType : public Type {
 public:
  GenericType(Identifier *name, Type *delegateType) : Type(name), delegateType(delegateType) {}

  Identifier *getName() { return delegateType->getName(); }
  VariableSet &getVariables() { return delegateType->getVariables(); }
  MethodSet &getMethods() { return delegateType->getMethods(); }
  TypeList getParents() { return delegateType->getParents(); }

  // true if delegateType exists and is specialized
  bool isSpecialized() { return delegateType && delegateType->isSpecialized(); }
  GenericType *specialize(Type *delegateType); // TODO: implement move semantics?
 protected:
  Type *delegateType;
};

class FunctionType : public TemplatedType {
 public:
  // TODO: functions as objects have methods (namely, apply())
  FunctionType(TypeList argTypes, Type *returnType);
  GenericTypeList buildGenericTypes(TypeList argList, Type *returnType);

  TypeList getArgTypes();
  Type *getReturnType();
};

}
